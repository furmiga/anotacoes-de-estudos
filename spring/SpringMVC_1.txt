 @Component -> usado em classes para o sprin gerenciar
 @Bean -> usado em metodos para o spring gerenciar
 
 JBoss Forge, um framework criado pela JBoss para a criação da estrutura inicial do projeto.
	-O JBoss Forge é um gerador de projetos Java, e ele gera toda a estrutura base do projeto integrada ao Maven. Além disso, configura dependências (bibliotecas e frameworks), estrutura de pastas e gera configurações iniciais que normalmente envolve arquivos XML.
	Sem ele, em um projeto tipicamente Java EE, devemos criar vários arquivos XML manualmente, por exemplo: persistence.xml, web.xml, faces-config.xml, pom.xml, beans.xml entre outros.
	
	-Apos baixar o jboos forge va ate a pasta bin e execute o script forge
	
	-Neste momento, já dentro do terminal do JBoss, podemos digitar e executar o seguinte comando para criar o projeto: project-new --named casadocodigo. Este comando indica para o JBoss que queremos um novo projeto (project-new) e que este projeto terá o nome casadocodigo (--named casadocodigo).
		Obs: Observação: Nas versões mais recentes do JBoss o comando para criar um novo projeto mudou para new-project, ou seja, utilize o comando new-project --named casadocodigo para criar o projeto caso encontre o erro: ***ERROR*** No such command: project-new .
		
		
	Obs: tudo que esta dentro do WEB-INF automaticamente ja é protegido pelo servidor de aplicação

Aula 1	

	CRIANDO NOSSO PRIMEIRO CONTROLLER
		
		//@Controller tem como função falar para o spring obviamente que esta classe é um controller do nosso MVC
		@Controller
		public class HomeController{
			
			//@RequestMapping, tem a função de definir que aquele metodo atende a um determinado path ou endereço. Neste caso estamos definindo que o metodo index atenderá as requisições que chegarem na raiz do nosso projeto ("/")
			@RequestMapping("/")
			public String index(){
				System.out.println("Entrando na home da CDC");
				//Aqui estou informando a view que eu quero retornar, no caso home.jsp
				//No nosso exemplo a home esta dentro do WEB-INF/views, mas eu não precisei passar todo o path e nem o sufixo jsp, pq eu ja configurei isso na nossa classe de configuração AppWebConfiguration
				return "home"
			}
		
		}

		Em nenhum momento até agora, configuramos o SpringMVC para atender as requisições que chegam para nossa aplicação
		- Agora precisamos configurar uma servlet do spring para atender as requisições, podemos fazer isso por XML ou código java (vamos fazer aqui por codigo java)
			
		public class ServletSpringMVC extends AbstractAnnotationConfigDispatcherServletInitializer{
			@Override
			protected Class<?>[] getRootConfigClasses() {
				return null;
			}

			@Override
			protected Class<?>[] getServletConfigClasses() {
				 //essa classe sera criada logo abaixo
				 //a classe AppWebConfiguration será usada como classe de configuração do servlet do SpringMVC
				 return new Class[] {AppWebConfiguration.class};
			}

			
			//pede um array com os mapeamentos que queremos que nosso servlet atenda
			@Override
			protected String[] getServletMappings() {
				//Como estas configurações estamos definindo que o servlet do SpringMVC atenderá as requisições a partir da raiz do nosso projeto (/)
				return new String[] {"/"};
			}
		}
		
		//@EnableWebMvc utilizado para usar o recurso de Web MVC do SpringMVC
		@EnableWebMvc
		//Aqui estou mostrando para o spring qual o pacote (pacote da classe que eu passei) o SpringMVC irá encontrar os nossos controllers!
		//Aqui eu passei a classe mas eu poderia usar o basePackages={""} e passar o pacote direto, neste exemplo preferimos usar a classe e o spring decobre o pacote de forma automatica
		ComponentScan(basePackageClasses={HomeController.class})
		public class AppWebConfiguration {
			
			//A anotação @Bean é para que o retorno da chamada deste metódo possa ser gerenciada pelo SpringMVC, sem ela nossa configuração não funciona
			@Bean
			public InternalResourceViewResolver internalResourceViewResolver(){
				InternalResourceViewResolver resolver = new InternalResourceViewResolver();
				resolver.setPrefix("/WEB-INF/views/");
				resolver.setSuffix(".jsp");
				return resolver;
			}
		}
	
Aula 2

	BIND DO SPRING
	
		Criamos uma pagina qualquer com um form 
		
		<form action="/produtos" method="post">
			<div>
				<label>Título</label>
				<input type="text" name="titulo" />
			</div>
			<div>
				<label>Descrição</label>
				<textarea rows="10" cols="20" name="descricao"></textarea>
			</div>
			<div>
				<label>Páginas</label>
				<input type="text" name="paginas" />
			</div>
			<button type="submit">Cadastrar</button>
		</form>
		
		Criamos um produto controller 
		
		@Controller
		public class ProdutosController {

			@RequestMapping("/produtos/form")
			public String form(){
				...
			}
			
			//perceba que os nomes dos parametros do metodo são os mesmos passados no name dos inputs do html, o spring ja faz esse bind, pegando o name e vendo qual atributo tem o mesmo nome (o bixão é foda mesmo)
			//Eu poderia tambem ao inves de passar os parametro passar direto uma classe, por exemplo Produto com os atributos(com getter e setter), o spring irira visualizar essa classe e ver os parametros de mesmo nome e populalos
			//Ex: public String gravar(Produto produto)
			@RequestMapping("/produtos")
			public String gravar(String titulo, String descricao, int paginas){
				System.out.println(titulo);
				System.out.println(descricao);
				System.out.println(paginas);

				return "ok";
			}

		}
		
	Preparando o Spring com JPA
		
	
		Vamos criar uma classe de DAO
		
		//Para que essa classe possa ser injetada pelo spring na classe ProdutosController(logo abaixo), temos que fazer com que essa classe seja gerenciada pelo Spring
		//Para isso devemos marcar o ProdutoDAO com a anotação @Repository, eu poderia usar tambem o @Component tambem, porem por questão de semantica mesmo vamos usar o @Repository
		//Observação: @Repository extende de @Component
		@Repository
		public class ProdutoDAO {

			//EntityManager é fornecido pelo Spring com esta anotação
			@PersistenceContext
			private EntityManager manager;

			public void gravar(Produto produto){
				manager.persist(produto);
			}
		}
		
		Mesmo anotando com @Repository o spring não ira conseguir localizar esta classe para injeta-la, precisamos configura-la na nossa classe AppWebConfiguration na qual configuramos para o Spring encontrar nossos controllers.
		Nós vamos configurar para que encontre nossos daos também. A anotação @ComponentScan deve ficar assim:
		ComponentScan(basePackageClasses={HomeController.class, ProdutoDAO.class})
		
		
		Agora na classe de controller vamos injetar esse ProdutoDAO
		
		@Controller
		public class ProdutosController {

			//A anotação @Autowired serve para que nós não nos preocupemos em criar manualmente o ProdutoDAO no Controller
			@Autowired
			private ProdutoDAO produtoDao;

			@RequestMapping("/produtos")
			public String gravar(Produto produto){
				System.out.println(produto);
				produtoDao.gravar(produto);
				return "/produtos/ok";
			}
			[...]
		}
		
		Precisamos agora tambem criar nossas configurações do JPA para que o spring possa gerenciar o nosso EntityManager passado no nosso ProdutoDAO, sem isso o spring não consegue injetar o EntityManager
			
		Nesta classe estamos criando um único método, que será usado pelo Spring para gerar o EntityManager
		public class JPAConfiguration {

			@Bean
			public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
				LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
				JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();

				//Estou passando que o adaptador de JPA que eu vou utilizar é o hibernate, poderia ser outro, por exemplo eclipseLink
				factoryBean.setJpaVendorAdapter(vendorAdapter);

				DriverManagerDataSource dataSource = new DriverManagerDataSource();
				dataSource.setUsername("root");
				dataSource.setPassword("");
				dataSource.setUrl("jdbc:mysql://localhost:3306/casadocodigo");
				dataSource.setDriverClassName("com.mysql.jdbc.Driver");

				factoryBean.setDataSource(dataSource);

				Properties props = new Properties();
				props.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQL5Dialect");
				props.setProperty("hibernate.show_sql", "true");
				props.setProperty("hibernate.hbm2ddl.auto", "update");

				factoryBean.setJpaProperties(props);

				//Aqui eu informo onde estão minhas entidades
				factoryBean.setPackagesToScan("br.com.casadocodigo.loja.models");

				return factoryBean;
			}
		}			
		
		
		Exercicio
			Dentro do ProdutosControllers, para utilizarmos o produtoDAO do tipo ProdutoDAO simplesmente anotamos o objeto com a annotation @Autowired do Spring. Por que ao invés de instanciarmos manualmente, fizemos essa abordagem?
				R:Utilizamos o @AutoWired para indicar ao Spring que o objeto anotado é um Bean dele e que queremos que ele nos dê uma instância por meio do recurso de injeção de dependência.
		
		
		Uma coisa importante precisamos passar o JpaConfiguration para o Spring, caso contrario ele não ira conseguir resolver nosso EntityManager
		
		na classe ServletSpringMVC
		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class[] {AppWebConfiguration.class, JPAConfiguration.class};
		}
		
	Configurando o TransactionManagement
	
		Se tentarmos rodar a aplicação um erro ira ocorrer Request processing failed; nested exception is javax.persistence.TransactionRequiredException: No transactional EntityManager available
		
		Note que o erro é bem claro: No transactional EntityManager available do tipo TransactionRequiredException. Ou seja, nossa operação com o banco de dados deve ser gerenciada com uma transação.
		
		Primeiro precisaremos de um TransactionManager que conheça nosso EntityManager para que assim ele possa gerenciar as transações de nossas entidades.
		
		Na classe JPAConfiguration adicionaremos mais um método que criará o TransactionManager.
		
		//@EnableTransactionManagement faz com que o Spring ative o gerenciamento de transações e já reconhece o TransactionManager
		@EnableTransactionManagement
		public class JPAConfiguration {

			[...]

			@Bean
			public JpaTransactionManager transactionManager(EntityManagerFactory emf){
				return new JpaTransactionManager(emf);
			}
		}
		
		Agora precisamos definir que o nosso ProdutoDAO é uma classe Transancional e fazemos isso através da anotação @Transactional do pacote org.springframework.transaction.annotation.Transactional.
		@Repository
		@Transactional
		public class ProdutoDAO {
			[...]
		}
		
Aula 3

	ModelAndView
		
		Quando queremos retornar para o front objetos para popular a tela, utilizamos o ModelAndView
			
			@RequestMapping("/produtos/form")
			public ModelAndView form(){

				ModelAndView modelAndView = new ModelAndView("produtos/form");
				modelAndView.addObject("tipos", TipoPreco.values());

				return modelAndView;
			}
			
		No front end vamos usar foreach da taglib 
			observação:  Para que as tags da JSTL funcionarem, lembre-se de fazer o importe da taglib logo após a diretiva de página JSP no início do arquivo.
				<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>

				<!-- Import da taglib -->
				<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
				
			
			Nosso laço(forEach), manipula o html do formulário para criar os campos de tipos de preços, e o resultado deste laço é algo como:
				
				<c:forEach items="${tipos}" var="tipoPreco" varStatus="status">
					<div>
						<label>${tipoPreco}</label>
						<input type="text" name="precos[${status.index}].valor">
						<input type="hidden" name="precos[${status.index}].tipo" value="${tipoPreco}">
					</div>
				</c:forEach>

		Exercicio:
			Em diversos métodos mapeados dos nossos controllers, costumamos retornar uma String para devolvermos uma página assim que aquele método for chamado. Entretanto, em alguns métodos, ao invés de utilizarmos o retorno de String, retornamos a classe ModelAndView. Porque utilizamos a classe ModelAndView ao invés da String?
				R: Quando utilizamos o ModelAndView, além retornar uma página, temos a possibilidade de enviar objetos de qualquer classe para essas páginas. Em outras palavras, dessa forma somos capazes de exibir, por exemplo, as informações das nossas classes modelos.
	
	Mais anotacoes JPA @Embeddable/@ElementCollection
		
		vamos criar a classe precoa
			public class Preco {

				private BigDecimal valor;
				private TipoPreco tipo;

				public BigDecimal getValor() {
					return valor;
				}

				public void setValor(BigDecimal valor) {
					this.valor = valor;
				}

				public TipoPreco getTipo() {
					return tipo;
				}

				public void setTipo(TipoPreco tipo) {
					this.tipo = tipo;
				}

			}
		
		Agora, adicione esses preços na classe Produto. Como cada livro pode ter mais de um preço, utilize uma lista. Gere também o getter e setter desse atributo:
			
			@Entity
			public class Produto {

				private List<Preco> precos;

				public List<Preco> getPrecos() {
					return precos;
				}

				public void setPrecos(List<Preco> precos) {
					this.precos = precos;
				}

					// restante do código omitido

			}	
		
		Anote a classe Preco com @Embeddable, que a permite ser persistida, desde que ela seja um atributo de uma entidade, e no caso ela é um atributo da classe Produto, que é uma entidade:
		
			@Embeddable
			public class Preco {

				// restante do código omitido

			}
			
		Para indicar que você irá armazenar uma lista de Preco, de uma classe @Embeddable, utilize a anotação @ElementCollection. Portanto, anote o atributo precos da classe Produto:
		
			@ElementCollection
			private List<Preco> precos;
			
Aula 4

	Informar se um metodo vai atender apens get ou post
	
		perceba que eu infomeri agora o value, pois como vou passar mais de um parametro para a anotação @RequestMapping, eu preciso passar esse value e depois o method
				
		@RequestMapping(value="/produtos", method=RequestMethod.POST)
		public String gravar(Produto produto){
			[...]
		}


		@RequestMapping(value="/produtos", method=RequestMethod.GET)
		public ModelAndView listar(){
			[...]
		}
		
	Enconding
	
		Para definirmos qual enconding o spring vai trabalhar, nós iremos usar filtros do proprio spring, para isso vamos para a classe ServeltSpringMVC e vamos criar mais um método de configuração do Spring
		
		Existe um método chamado getServletFilters usado pelo Spring que espera receber um array de filtros. Então vamos criar um CharacterEncodingFilter, definir o encoding deste filtro usando o valor "UTF-8", adicionar este filtro ao array de filtros e o retornar esse array para o Spring. Use os imports import javax.servlet.Filter e org.springframework.web.filter.CharacterEncodingFilter.
	
		public class ServletSpringMVC extends AbstractAnnotationConfigDispatcherServletInitializer{

			//outros métodos omitidos

			@Override
			protected Filter[] getServletFilters() {
				CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();
				encodingFilter.setEncoding("UTF-8");
				return new Filter[] {encodingFilter};
			}
		}	
		
	Melhorando as nossas rotas
	
		Vamos fazer agora um pequeno ajuste em nosso ProdutosController para deixar o mapeamento das rotas mais simples. Note que em todos os métodos usamos a anotação @RequestMapping passando sempre /produtos.
		Para que não precisemos ficar passando /produtos em todos os métodos do controller, vamos pôr essa anotação em nossa classe. Assim podemos remover o /produtos de todos os métodos e o Spring se encarrega de carregar os mapeamentos baseados no mapeamento da classe. Sendo assim nossa classe ProdutosController deve ficar parecida com o código abaixo:
		
		@Controller
		@RequestMapping("produtos")
		public class ProdutosController {
			[...]

			//ANTES - @RequestMapping("produtos/form")
			@RequestMapping("/form")
			public ModelAndView form(){
				[...]
			}

			//ANTES - @RequestMapping(value="/produtos",method=RequestMethod.POST)
			@RequestMapping(method=RequestMethod.POST)
			public String gravar(Produto produto){
				[...]
			}

			//ANTES - @RequestMapping(value="/produtos",method=RequestMethod.GET)
			@RequestMapping(method=RequestMethod.GET)
			public ModelAndView listar(){
				[...]
			}

		}
		
Aula 5

	Redirect
		Para realizar um redirect no spring temos que usar o ModelAndView usando como rota o redirect:xxx
		
		@RequestMapping(method=RequestMethod.POST)
		public ModelAndView gravar(Produto produto){
			System.out.println(produto);
			produtoDao.gravar(produto);
			return new ModelAndView("redirect:produtos");
		}
		
		agora vamos mostrar uma msg de sucesso apos a gravação
		
		@RequestMapping(method=RequestMethod.POST)
		public ModelAndView gravar(Produto produto, RedirectAttributes redirectAttributes){
			System.out.println(produto);
			produtoDao.gravar(produto);
			ModelAndView modelAndView = new ModelAndView("redirect:produtos")
			modelAndView.addObject("sucesso","Produto cadastrado com sucesso!");
			return new ModelAndView("redirect:produtos");
		}
		
		caso eu faça da forma acima, eu irei passar esse atributo pela url, ficando com uma url suja e não conseguindo acessar o atributo atraves de uma express language, para resolver esse problema bas usarmos o flashScope, que sera explicado no item abaixo
		
		
		
		Exercicios:
			Por que devemos sempre fazer um redirect após o formulário enviar um POST para nossos sistemas?
				R: Pois ao fazer F5 o navegador repete o ultimo request que ele realizou, e quando esse resquest é um POST, todos os dados que foram enviados também são repetidos. Se você realizou um insert no banco de dados, esse insert será repetido. Ou mesmo se realizou alguma operações que envia e-mail, por exemplo, o e-mail será enviado duas vezes ao pressionar F5.
				   Para evitar qualquer problema de dados reenviados, realizamos um redirect após um formulário com POST.
	
	FlashScoped
	
		Para que possamos manter um atributo de uma requisição para outra, por exemplo apos de um redirect eu preciso utilizar o FlashScoped
		O metodo mostrado logo acima ficaria desta maneira
		
		@RequestMapping(method=RequestMethod.POST)
		public ModelAndView gravar(Produto produto, RedirectAttributes redirectAttributes){
			System.out.println(produto);
			produtoDao.gravar(produto);
			redirectAttributes.addFlashAttribute("sucesso","Produto cadastrado com sucesso!");
			return new ModelAndView("redirect:produtos");
		}		
		
		Observação: Atributos do tipo Flash têm uma particularidade que é interessante observar. Eles só duram até a próxima requisição, ou seja, transportam informações de uma requisição para a outra e, então, deixam de existir.
				
		Note que usamos um RedirectAttributes. Isto faz muito sentido, já que após o post iremos redirecionar a página. A prática de fazer redirecionamentos após posts tem um nome bem conhecido, Always redirect after post (em português, significa Sempre redirecione após post).
		
		Exercicios:
			O que é o Flash Scoped que usamos através do objeto RedirectAttributes do Spring?
				R:O Flash Scoped é um escopo onde os objetos que adicionamos nele através do método addFlashAttribute ficam vivos de um request para outro, enquanto o navegador executa um redirect (usando o código de status 302).
	
	
	
Aula 6
	
	Validação com spring
		
		Para usar o validador do spring, precimaos baixar as dependencias da especificação do bean validation, pois o spring usa essa especificação por baixo dos panos
		
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<version>1.0.0.GA</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>4.2.0.Final</version>
		</dependency>
		
		vamos criar a classe que sera nosso validador
		
		public class ProdutoValidation implements Validator {

			//Aqui sera passado quais as classes esse validados suporta(tipo minhas classes de negocio que serão validadas)
			@Override
			public boolean supports(Class<?> clazz) {
				return Produto.class.isAssignableFrom(clazz);
			}

			//o primeiro parametro é a classe que sera validada
			//o segundo parametro é a classe de erros que sera popupalada com informações tais como, se a validação passou ou não, depois eu usso essa classe para verificar se as validações passaram
			@Override
			public void validate(Object target, Errors errors) {
				ValidationUtils.rejectIfEmpty(errors, "titulo", "field.required");
				ValidationUtils.rejectIfEmpty(errors, "descricao", "field.required");

				Produto produto = (Produto) target;

				if(produto.getPaginas() <= 0) {
					errors.rejectValue("paginas", "field.required");
				}
			}

		}
		
		Agora na classe que iremos utilizar o validator vamos criar o metodo initBinder
		Essa classe é responsavel por vincular o validador com o controller
		
		@InitBinder
		public void initBinder(WebDataBinder binder) {
			binder.addValidators(new ProdutoValidation());
		}
		
		Agora no método que ira utilizar o validator faremos assim:
		
		//Anotação @valid informa que esse produto sera validado pelo nosso validator(que vinculamos no método acima)
		//Passamos como parametro o BindingResult(a ordem dos parametro neste caso influencia, portando este cara teem que vir logo apos a nossa classe que sera validada)que tera informações por exemplo se o novvo validator retornou erro ou não
		@RequestMapping(method=RequestMethod.POST)
		public ModelAndView gravar(@Valid Produto produto, BindingResult result, 
				RedirectAttributes redirectAttributes) {

			//Aqui estamos verificando se ocorreu algum erro na validação
			if (result.hasErrors()) {
				return form();
			}

			produtoDao.gravar(produto);

			redirectAttributes.addFlashAttribute("sucesso", "Produto cadastrado com sucesso!");

			return new ModelAndView("redirect:produtos");
		}		
	
		Exercicio:
			Por quê utilizamos o Validator do Spring ao invés de fazer as validações manualmente?
				R: Quando utilizamos o Validator do Spring, temos a possibilidade de configurar o controller para que utilize automaticamente o validador todas as vezes que for necessário validar a classe desejada, ou seja, a classe que precisa ser validada (anotada com @Valid). Vale lembrar que o uso do InitBinder é necessário para que seja possível essa validação automática.
	
	

Aula 7
	
	Exibindo mensagens de erro na tela
		Vamos primeiramente criar um arquivo de properties messages.properties na pasta WEB-INF:
			
			
			field.required = Campo obrigatório
			field.required.produto.titulo = O título é obrigatório
			field.required.produto.paginas = Informe o número de páginas
			field.required.produto.descricao = A descrição é obrigatória
			typeMismatch = O tipo de dado é inválido
			typeMismatch.produto.paginas = Digite um valor válido. Exemplo: "100"
			
		Obs: Assim que o arquivo for salvo, clique nele com o botão direito do mouse e selecione Properties. Em Text file encoding, verifique se o encoding é UTF-8, caso não seja, altere-o.
		
		Para o Spring encontrar o arquivo messages.properties, crie um novo método na classe AppWebConfiguration, que irá retornar o arquivo com algumas configurações. Crie um novo método como o exemplo abaixo:
		
			//lembrando que para o spring gerenciar este metodo eu preciso anotar ele como @bean
			@Bean
			public MessageSource messageSource() {
				ReloadableResourceBundleMessageSource messageSource =
					new ReloadableResourceBundleMessageSource();

				messageSource.setBasename("/WEB-INF/messages");
				messageSource.setDefaultEncoding("UTF-8");
				messageSource.setCacheSeconds(1);

				return messageSource;
			}
		
		Para adicionar as mensagens no formulário form.jsp, adicione uma nova taglib:
		
			%@ taglib uri="http://www.springframework.org/tags/form" prefix="form" %>
		
		Além disso, substitua a tag <form> para:
		
			<form:form action="/casadocodigo/produtos" method="POST" commandName="produto">
			
			Obs: Caso esteja usando dependências atualizadas e der o erro Unable to find setter method for attribute: [commandName], troque o commandName para modelAttribute.
			
		Adicione as mensagens de erro para os campos de título, descrição e páginas:
	
			<form:form action="/casadocodigo/produtos" method="POST" commandName="produto">
				<div>
					<label>Título</label> 
					<input type="text" name="titulo">
					<form:errors path="titulo" />
				</div>
				<div>
					<label>Descrição</label>
					<textarea rows="10" cols="20" name="descricao"></textarea>
					<form:errors path="descricao" />
				</div>

				<div>
					<label>Páginas</label>
					<input type="text" name="paginas">
					<form:errors path="paginas" />
				</div>

				<c:forEach items="${tipos}" var="tipoPreco" varStatus="status">
					<div>
						<label>${tipoPreco}</label>
						<input type="text" name="precos[${status.index}].valor">
						<input type="hidden" name="precos[${status.index}].tipo" value="${tipoPreco}">
					</div>
				</c:forEach>
				<button type="submit">Cadastrar</button>
			</form:form>	
			
	Usando taglib do spring para chamar o controller direto, ao invez de passar a url do mesmo

		adicionar a taglib 
			<%@ taglib uri="http://www.springframework.org/tags" prefix="s" %>
			
		E use o método mvcUrl("controller#metodo").build() para criar a URL:
			<form:form action="${s:mvcUrl('PC#gravar').build()}" method="POST" commandName="produto">
			
		O controller é referenciado pelas suas letras maiúsculas, então ProdutosController vira PC.
		
		Por fim, para que a URL possa ser construída de forma correta, separando os contextos, modifique o @RequestMapping do ProdutosController para /produtos:
		
			@Controller
			@RequestMapping("/produtos")
			public class ProdutosController {

				// restante do código omitido

			}
			
	
	Conclusão sobre o @Valid
	
		quando eu coloco esta anotação por padrão o spring ja faz algumas validações, como por exemplo verificar se o conteudo ionformado na tela é do tipo do campo na hora do bind,
		por exemplo , é para digitar um inteiro o cara deixa vazio
		
		quando ocorre um erro ele ja tem alguns codigos de erro, por exemplo se deu esse erro de conversão, o codigo de erro é typeMismatch, por isso no message.properties, se eu quiser colocar uma messagem de erro para esse tipo de erro eu tenho que colocar o prefixo typeMismatch e depois a classe e o campo ex:
		typeMismatch.produto.paginas = Digite um valor válido. Exemplo: "100"
		ou deixar uma msg generica 
		typeMismatch = O tipo de dado é inválido
		
Aula 8
		
	Manipulando data no spring - usando a anotacao @DateTimeFormat
		
		
		@DateTimeFormat(pattern="dd/MM/yyyy")
		private Calendar dataLancamento;
		
		 Na jsp, crie mais uma div:
			
			<div>
				<label>Data de Lançamento</label>
				<input name="dataLancamento" type="text" />
				<form:errors path="dataLancamento" />
			</div>	
			
		desta forma o spring vai fazer o bind do que foi inputado na tela para o campo, no formato definido no pattern
		
	Usando configuração de data para TODOS os campos de data
	
		Se usarmos a forma aprendida anteriormente, teremos que colocar a anotação @DateTimeFormat para todos os campos data da aplicação,
		para deixar esta configuração em um unico lugar, vamos criar um Conversor na nossa classe de Configuração
		
		AppWebConfiguration, criar o método abaixo:
		
		@Bean
		public FormattingConversionService mvcConversionService() {
			DefaultFormattingConversionService conversionService = 
				new DefaultFormattingConversionService();
			DateFormatterRegistrar registrar = new DateFormatterRegistrar();
			registrar.setFormatter(new DateFormatter("dd/MM/yyyy"));
			registrar.registerFormatters(conversionService);

			return conversionService;
		}
		
	Deixando o spring tomar conta dos inputs
		
		Se um campo estiver invalido a msg de erro ira aparecer, porem se vc colocar valor neste campo mas outros campos continuarem invalidos, a msg do campo que vc informou vai sumir, porem o conteudo inbutido nele tambem
		para arrumar isso vamos deicar o srping tomar conta dos nossos inputs
		
		troque as tags do formulário no form.jsp de <input type="text" name="nome" /> para <form:input path="nome" />, por exemplo. Ele ficará com a seguinte estrutura:
		
		<form:form action="${s:mvcUrl("PC#grava").build() }" method="post" 
			commandName="produto">    

			<div>
				<label>Título</label>
				<form:input path="titulo" />
				<form:errors path="titulo" />
			</div>
			<div>
				<label>Descrição</label>
				<form:textarea path="descricao" rows="10" cols="20"/>
				<form:errors path="descricao" />
			</div>name
			<div>
				<label>Páginas</label> 
				<form:input path="paginas" />
				<form:errors path="paginas" />
			</div>
			<div>
				<label>Data de lançamento</label>
				<form:input path="dataLancamento" />
				<form:errors path="dataLancamento" />
			</div>
			<c:forEach items="${tipos}" var="tipoPreco" varStatus="status">
				<div>
					<label>${tipoPreco}</label> 
					<form:input path="precos[${status.index}].valor" />
					<form:hidden path="precos[${status.index}].tipo" 
						value="${tipoPreco}" />
				</div>
			</c:forEach>
			<button type="submit">Cadastrar</button>
		</form:form>		
		
		mas para isso funcionar , faça o método form() do ProdutoController receber um Produto:
		
			@RequestMapping("form")
			public ModelAndView form(Produto produto) {
				ModelAndView modelAndView = new ModelAndView("produtos/form");
				modelAndView.addObject("tipos", TipoPreco.values());

				return modelAndView;
			}	

		 O método gravar, também do ProdutoController irá apresentar um erro, pois dentro dele há uma chamada para o método form. Então passe um Produto para ele:
		 
			@RequestMapping(method=RequestMethod.POST)
			public ModelAndView grava(@Valid Produto produto, BindingResult result, 
					RedirectAttributes redirectAttributes) {

				if(result.hasErrors()) {
					return form(produto);
				}

				produtoDao.gravar(produto);

				redirectAttributes.addFlashAttribute("sucesso", "Produto cadastrado com sucesso!");

				return new ModelAndView("redirect:produtos");
			}	
			
Aula 9

	Enviando arquivo para o servidor - MultiPart
	
		Começaremos a fazer esta mudança a partir do formúlário de cadastro de produtos. O form.jsp
		
		<div>
			<label>Sumário</label>
			<input name="sumario" type="file" /> --> o type file é um atributo do html 5 para seleção de arquivo
		</div>
			
	Configure o Spring para trabalhar com arquivos. Na classe AppWebConfiguration, crie o seguinte método:
		
		@Bean
		public MultipartResolver multipartResolver() {
			return new StandardServletMultipartResolver();
		}	
		
	Além disso, altere a configuração das servlets. Então, na classe ServletSpringMVC, sobrescreva o seguinte método:
		
		@Override
		protected void customizeRegistration(Dynamic registration) {
			// O MultipartConfigElement espera receber uma String que configure o arquivo. Não usaremos nenhuma configuração para o arquivo, queremos receber este do jeito que vier.
			registration.setMultipartConfig(new MultipartConfigElement(""));
		}	
			
	vamos criar uma classe responsavel por salvar o arquivo no nosso servidor
		@Component
		public class FileSaver {

			@Autowired
			private HttpServletRequest request;

			public String write(String baseFolder, MultipartFile file) {

				try {
					String realPath = request.getServletContext().getRealPath("/" + baseFolder);
					String path = realPath + "/" + file.getOriginalFilename();
					file.transferTo(new File(path));

					return baseFolder + "/" + file.getOriginalFilename();

				} catch (Exception e) {
					throw new RuntimeException(e);    
				}

			}
		}
	
	vamos usar agora a classe criada no nosso controller
		
		@Autowired
		private FileSaver fileSaver;
		
		//aqui passamos o primeiro parametro MultiPartFile para receber esse cara da pagina
		@RequestMapping(method=RequestMethod.POST)
		public ModelAndView gravar(MultipartFile sumario, @Valid Produto produto, 
				BindingResult result, RedirectAttributes redirectAttributes) {

			if(result.hasErrors()) {
				return form(produto);
			}

			String path = fileSaver.write("arquivos-sumario", sumario);
			produto.setSumarioPath(path);

			produtoDao.gravar(produto);

			redirectAttributes.addFlashAttribute("sucesso", "Produto cadastrado com sucesso!");

			return new ModelAndView("redirect:produtos");
		}
		
	Crie a pasta arquivos-sumario dentro de src/main/webapp/.
	
	Por fim, para o Spring encontrar o FileSaver, adicione-o na anotação @ComponentScan, na classe AppWebConfiguration:

		@EnableWebMvc
		@ComponentScan(basePackageClasses={HomeController.class, ProdutoDAO.class, 
			FileSaver.class})
		public class AppWebConfiguration {

			// restante do código omitido

		}

Aula 10
	Lberar acesso para a pasta resource
		Por padrão, o Spring MVC nega o acesso à pasta resources. Consequentemente, o Tomcat não pode carregar os arquivos CSS (e a página fica sem design)
		Para liberar o acesso, é preciso fazer duas alterações na classe AppWebConfiguration
		A classe deve estender a classe WebMvcConfigurerAdapter:
		
			@EnableWebMvc
			@ComponentScan(basePackageClasses= {HomeController.class, ProdutoDAO.class, 
				FileSaver.class})
			public class AppWebConfiguration extends WebMvcConfigurerAdapter {

				// restante do código omitido

			}	

		A classe deve implementar o método configureDefaultServletHandling para liberar o acesso:

			@Override
			public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
				configurer.enable();
			}				
		
	URL amigavel
		O Spring já traz um sistema de URLs amigáveis, que são URLs que parecem texto e não ficam poluídas com ? e &. Então edite o método detalhe, adicionando uma variável na rota e usando a anotação @PathVariable para mapear essa variável a um parâmetro:
		
			@RequestMapping("/detalhe/{id}")
			public ModelAndView detalhe(@PathVariable("id") Integer id){

				ModelAndView modelAndView = new ModelAndView("/produtos/detalhe");
				Produto produto = produtoDao.find(id);
				modelAndView.addObject("produto", produto);

				return modelAndView;
			}	

Aula 11
	
	Expondo um bean para toda a aplicação poder usar
	
	na classe AppWebConfiguration  no metodo internalResourceViewResolver, colocamos o seguinte trecho
	
		@EnableWebMvc
		@ComponentScan(basePackageClasses={HomeController.class, ProdutoDao.class, 
			FileSaver.class, CarrinhoCompras.class})
		public class AppWebConfiguration {

			@Bean
			public InternalResourceViewResolver internalResourceViewResolver() {

				InternalResourceViewResolver resolver = 
					new InternalResourceViewResolver();
				resolver.setPrefix("/WEB-INF/views/");
				resolver.setSuffix(".jsp");

				//Aqui eu exponho esse cara para toda a minha aplicação utilizar, o spring ficar responsavel por deixar ele exposto para as JSPs utilizarem
				resolver.setExposedContextBeanNames("carrinhoCompras");
				
				//esse cara expoe TODOS os beans para o spring poder utilizar nas JSPs
				//resolver.setExposeContextBeansAsAttributes(true)
				
				
				return resolver;
			}

			// restante do código omitido
		}
		

Aula 12
	Escopo Default dos beans do spring
		Quando anotamos uma classe para se transformar em um bean do spring (@Controller/@Component/@Repository etc...) por padrão ela é um singleton, o escopo dela é por aplicação
	
	Escopo sessao
		para tranformar o escopo de um bean, temos que usar a anotação @Scoped
			@Component
			@Scope(value=WebApplicationContext.SCOPE_SESSION)
			public class CarrinhoCompras {
				[...]
			}
	
	
	Problemas com injeção de beans com escopos menos abrangentes
		Porem vamos usar o CarrinhoCompras em um @Controller (CarrinhoComprasController) este controller esta com o escopo default (application) e o escopo de aplicação é mais abrangente que o escopo de sessão, por tanto o spring não ira permitir injetar uma classe com escopo menos abrangente do que o bean atual
		para solucionar o problema vamos trnaformar nosso CarrinhoComprasController com o escopo de request
		
		@Controller
		@RequestMapping("/carrinho")
		@Scope(value=WebApplicationContext.SCOPE_REQUEST)
		public class CarrinhoComprasController {
			[...]
		}
		
	Problema do escopo de aplicação
		Por padrão, o Spring define que o escopo de todos os componentes é de application, ou seja, apenas uma instância existe desde quando a aplicação foi criada. O principal problema dessa abordagem é esse que acabamos de encontrar, os usuários compartilham sempre os mesmos dados, uma alteração afeta todo mundo que está conectado à nossa aplicação. Para resolver isso, precisamos mudar o escopo do nosso carrinho.
	
	Tipos de escopo
		 aplicação
			desde que o servidor é iniciado, apenas um objeto na memória é manipulado(singleton), o que causa conflito quando temos mais de um usuário usando a nossa aplicação
		 sessão
			o objeto é criado para cada usuário que se conecta à aplicação, ou seja, usuários diferentes usam objetos diferentes, o que é ideal para um carrinho de compras, uma vez que cada usuário possui o seu próprio carrinho
			Obs: lembrando que quando o escopo for sessão, implementar a classe com Serializable
		 request
			cada vez que acessamos a página, um objeto é criado

Aula 13
	s:mvcUrl passando parametros
	
		caso eu queira chamar um bean do spring direto e passando valores de parametros eu posso fazer da seguinte mandeira ${s:mvcUrl('CCC#remover').arg(0, valor).arg(1,valor).arg(x,valor).build() }
		Exemplo:
		
		Pagina
			<form action="${s:mvcUrl('CCC#remover').arg(0, item.produto.id).arg(1,item.tipoPreco).build() }" method="post">
				<input type="image" src="/excluir.png" alt="Excluir" title="Excluir" />
			</form>
		
		Bean
			@RequestMapping("/remover")
			public ModelAndView remover(Integer produtoId, TipoPreco tipoPreco){
				carrinho.remover(produtoId, tipoPreco);
				return new ModelAndView("redirect:/carrinho");
			}
	
	Estudar mais sobre @Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.TARGET_CLASS)
	
	Usando RestTemplate
		Para eu realizar uma chamada a um webservice eu posso utilizar o RestTemplate
		
		primeiro preciso baixar as dependencias do jackson
			<dependency>
				<groupId>com.fasterxml.jackson.core</groupId>
				<artifactId>jackson-core</artifactId>
				<version>2.5.1</version>
			</dependency>
			<dependency>
				<groupId>com.fasterxml.jackson.core</groupId>
				<artifactId>jackson-databind</artifactId>
				<version>2.5.1</version>
			</dependency>
		
		na classe que eu vou utilizar eu preciso injetar o restTemplate
		
			@Autowired
			RestTemplate restTemplate;
			
			Obs: Para injetar o restTemplate falta criar uma configuração básica para que o Spring consiga criar o objeto RestTemplate corretamente. Para isso criaremos um novo método na classe WebAppConfiguration anotado com @Bean e que apenas retorna um objeto do tipo RestTamplate.
					@EnableWebMvc
					@ComponentScan(basePackageClasses={HomeController.class, ProdutoDAO.class, FileSaver.class, CarrinhoCompras.class})
					public class AppWebConfiguration extends WebMvcConfigurerAdapter {
						[...]

						@Bean
						public RestTemplate restTemplate(){
							return new RestTemplate();
						}

					}				 
		
		O metodo de utilização ficaria assim
			
			@RequestMapping(value="/finalizar", method=RequestMethod.POST)
			public Callable<ModelAndView> finalizar(RedirectAttributes model){
				return () -> {
					String uri = "http://book-payment.herokuapp.com/payment";

					try {
						//primeiro parametro url
						//segundo parametro os dados que serão enviados (mais abaixo vou explicar como funciona melhor essa parte)
						//terceiro parametro o tipo do retorno que eu espero
						String response = restTemplate.postForObject(uri, new DadosPagamento(carrinho.getTotal()), String.class);
						model.addFlashAttribute("sucesso", response);
						System.out.println(response);
						return new ModelAndView("redirect:/produtos");
					} catch (HttpClientErrorException e) {
						e.printStackTrace();
						model.addFlashAttribute("falha", "Valor maior que o permitido");
						return new ModelAndView("redirect:/produtos");
					}
				};
				
		Dados enviados
			o nosso webService espera um json da seguinte maneira {"value": 500}
			no trecho que fazemos a chamada para ele passamos restTemplate.postForObject(uri, new DadosPagamento(carrinho.getTotal()), String.class);, note que o que estamos passando é o DadosDePagamento, abaixo a classe:
			
			public class DadosPagamento {

				private BigDecimal value;

				public DadosPagamento(BigDecimal value) {
					this.value = value;
				}

				public DadosPagamento() {
				}

				public getValue() {
					return value;
				}
			}	
			
			note que o nome do atributo é o mesmo esperado pelo json, no caso value, o spring mesmo faz essa conversão, utilizando o jackson ele serializa nossa classe no formato de json e usa o nome do atributo da classe como o nome do atributo json
			
	
	Requisições assincronas
		
		Nossa classe roda em apenas uma unica thread, então para dizer a ela para rodar um metodo em uma thread separada(assincrona), podemos usar o callable que foi implementado apartir da versão de servlets 3.0
		O metodo ficara assim:
		
		
		@RequestMapping(value="/finalizar", method=RequestMethod.POST)
		public Callable<ModelAndView> finalizar(RedirectAttributes model){
			return () -> {
				try {
					String uri = "http://book-payment.herokuapp.com/payment";
					String response = restTemplate.postForObject(uri, new DadosPagamento(carrinho.getTotal()), String.class);
					model.addFlashAttribute("message", response);
					System.out.println(response);
					return new ModelAndView("redirect:/produtos");
				} catch (HttpClientErrorException e) {
					e.printStackTrace();
					model.addFlashAttribute("message", "Valor maior que o permitido");
					return new ModelAndView("redirect:/produtos");
				}
			};
		}
		
		Observação: Observe que estamos usando novamente recursos do Java 8. Esta forma de usar lambda nos permite criar um objeto do mesmo tipo esperado pelo retorno do método, evitando que criemos uma classe anônima. Neste caso é perfeitamente aplicável o recurso, por que na interface Callable só há um método, de nome call.
		